from dataclasses import dataclass
from typing import Any, Callable, Literal, TypeAlias

StateCategory = Literal["TOWER", "UNIT"]

_Entry = dict[str, Any]
_EntriesById = dict[int, _Entry]
_DataByCategory = dict[StateCategory, _EntriesById]

_OnEvent: TypeAlias = "Callable[[StateEvent], None]"


class State:
    """
    Basically a 2-layer dict with this shape
    {
        category_1: {
            id_1: {
                prop_1: ...,
                prop_2: ...
            },

            id_2: {
                ...
            }
        },

        category_2: {
            ...
        }
    }

    all entries should have an id
    all entries for a category may not have the same shape (keys / value types),
        the consumer should know how to determine the data shape

    operations on this data are classified as one of...
        creation - new entry with unique id is added under a category
        update   - existing entry has one of its existing values updated
        delete   - entry is removed from a category

    all operations generate an "event" describing this change
    this event is pushed into a queue that's eventually flushed
        the motivation being that this allows the renderer process to both
        maintain a copy of this state and also animate the changes
            animations based on a state change usually only involve a single entity (eg unit movement)
            animations that involve multiple entities (eg tower attacking unit)
            are triggered by more specific events not generated by this class
    """

    data: _DataByCategory
    events: "list[StateEvent]"
    on_event: _OnEvent

    def __init__(self, on_event: _OnEvent):
        self.data = dict(TOWER=dict(), UNIT=dict())
        self.on_event = on_event

    def create(self, category: StateCategory, data: _Entry):
        self.data.setdefault(category, dict())
        self.data[category][data["id"]] = data

        ev = StateCreated(category=category, data=data)
        self._log_event(ev)

    def update(self, category: StateCategory, id: int, key: str, value: Any):
        self.data[category][id][key] = value

        ev = StateUpdated(category=category, id=id, key=key, value=value)
        self._log_event(ev)

    def delete(self, category: StateCategory, id: int):
        data = self.data[category][id]
        del self.data[category][id]

        ev = StateDeleted(category=category, data=data)
        self._log_event(ev)

    def _log_event(self, event: "StateEvent"):
        self.on_event(event)


@dataclass
class StateCreated:
    category: StateCategory
    data: Any

    @property
    def id(self):
        return self.data["id"]


@dataclass
class StateUpdated:
    category: StateCategory
    id: int
    key: str
    value: Any


@dataclass
class StateDeleted:
    category: StateCategory
    data: Any

    @property
    def id(self):
        return self.data["id"]


StateEvent = StateCreated | StateUpdated | StateDeleted
